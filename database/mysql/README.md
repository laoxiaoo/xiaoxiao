# Mysql连接

通过客户端/服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么

## 通信方式

1. 全双工：接受和发送数据能同步进行
2. 半双工：某一个时刻，只能发送/接受数据
3. 单工：只能发送/接收数据

## 线程状态

可以通过如下命令查看用户正在运行的线程信息，root用户能查看所有线程，其他用户只能看自己的

```shell
show processlist; 
```



# 查询缓存

这是MySQL的一个可优化查询的地方，如果开启了查询缓存且在
查询缓存过程中查询到完全相同的SQL语句，则将查询结果直接返回给客户端；（**8.0已弃用**）

> 即使开启查询缓存，以下SQL也不能缓存

1. 查询语句使用SQL_NO_CACHE
2. 查询的结果大于query_cache_limit设置
3. 查询中有一些不确定的参数，比如now()

> 可以通过如下命令查询缓存的一些参数

```shell
## 查看查询缓存是否启用，空间大小，限制等
show variables like '%query_cache%';
```

# 查询优化器

- 等价变换策略
  - 5=5 and a>5 改成 a > 5
  - a < b and a=5 改成b>5 and a=5
  - 基于联合索引，调整条件位置等
- 优化count、min、max等函数
    - InnoDB引擎min函数只需要找索引最左边
    - InnoDB引擎max函数只需要找索引最右边
    - MyISAM引擎count(*)，不需要计算，直接返回
- in的优化
    - MySQL对in查询，会先进行排序，再采用二分法查找数据。比如where id in (2,1,3)，变
        成 in (1,2,3)


# InnoDB文件存储结构

一个ibd数据文件-->Segment（段）-->Extent（区）-->Page（页）-->Row（行）

![image-20221116201804736](image/image-20221116201804736.png)

*tablespace*:表空间，用于存储多个ibd数据文件

*Segment*:段，用于管理多个Extent

*Extent*:区，一个区固定包含64个连续的页，大小为1M。当表空间不足，需要分配新的页资源，不会一页一页分，直接分配一个区

*Page*:页，用于存储多个Row行记录，大小为16K

*Row*：行，包含了记录的字段值，事务ID（Trx id）、滚动指针（Roll pointer）、字段指针（Field pointers）等信息