
# GC过程

![](./image/5-gc/2020052811241498.png)

1. Eden区内存满时，这时候触发一次**Minor GC**，把Eden区的存活对象转移到From区，非存活对象进行清理，然后给新创建的对象分配空间，存入Eden区
2. 随着分配对象的增多，Eden区的空间又不足了，这时候再触发一次Minor GC，清理掉Eden区和S1区的死亡对象，把存活对象转移到S2区，然后再给新对象分配内存
3. From区和To区是相对的关系，哪个区中有对象，哪个区就是From区，比如，再进行一次Minor GC，会把存活对象转移到S1区，再为转移之前，S2区是From区，S1区是To区，转移后，S2区中没有存活对象，变为To区，而S1区变为From区
4. 如果S区无法存放，则进入Old区
5. 大对象直接进入老年代，假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，**也不会存放在Eden区，而是直接存入老年代**
6. 长期存活的对象将进入老年代（默认15岁）

```shell
-XX:MaxTenuringThreshold=15
```
7. 如果某个(些)对象(原来在内存中存活的对象或者新创建的对象)由于以上原因需要被移动到老年代中，而老年代中没有足够空间容纳这个(些)对象，那么会触发一次Full GC

*总结*：**复制之后有交换，谁空谁是to.**(Eden采用复制算法/  Eden的存活对象少，所以需要复制的对象也少)

# GC日志查看示例

OutOfMemeryError之前一定发生FullGC，因为FullGC之后，老年代内存不够才会报错误

![](./image/20210509204844.png)

# GC算法

- 年轻代（YoungGeneration）的回收算法（回收主要以Copying为主）
  1. 所有新生成的对象首先都是放在年经代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象
  2. 新生代内存按照8 : 1 : 1的比例分为一个eden区和两个survivor(s0,s1）区。大部分对象在eden区中生成．回收时先将eden区存活对象复制到一个s0区，然后清空eden区，当下一次eden区又满了时，则将eden区和s0区存活对象复制到另一个s1区，然后清空eden和这个s0区，此时s0区是空的，然后将s0区和s1区交换，即保持s1区为空，如此往复.(**谁空谁是to**））。
  3. 当s1区不足以存放eden和survivoro的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次fulIGC(MajorGC)，也就是新生代、老年代都进行回收．
  4. 新生代发生的GC也叫做MinorGC,MinorGC发生频率比较高（不一走等Eden区满了才触发）.
- 老年代（OldGeneration）的回收算法（回收主要以Mark一Colnpact为主）
     1. 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中．因此，可以认为年老代中存放的都是一些生命周期较长的对象。
     2. 内存比新生代也大很多（大概比例是1:2)，当老年代内存满时触发MajorGC，发生频率比较低，老年代对象存活时间比较长，存活率标记高。
- 持久代（pernlallentGelleration）的回收算法
  用于存放静态文件，如java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些dass，例如Hibernate等，在这种时侯需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区
  
  

## Minor GC

- 只是新生代的垃圾回收
- 当年轻代**Eden区**空间不足，触发gc，回收eden和s0
  - **Survivol区满了不会触发GC**
- Minor GC时会引发STW，暂停其他用户线程

## Major GC

- 只是老年代的收集
  - CMS GC会单独收集老年代行为
  - 很多时候Major GC会和Full GC混淆使用，需要区分是老年代收集还是整堆收集
- 执行时间是Minor的10倍以上，停顿时间更长

## Full GC

- 整堆和方法区的垃圾回收
- 老年代空间不足，**方法区**空间不足，触发



# 算法优劣

## 复制算法

当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉

## 标记清除

首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，**它的标记过程其实就是前面的可达性分析算法中判定垃圾对象的标记过程**

# 逃逸分析

- 堆不是分配对象存储的唯一选择（也可以**栈上分配**/标量替换/同步消除）

## 栈上分配
- 一个对象，如果没有发生逃逸，则他的内存可以在栈上分配
- 判断逃逸：如果一个方法里的对象，可能被其他方法调用，则new 的对象发生逃逸
  （看new的对象是不是在外部表用）

```java
//这里A没有方法外部调用，没有发生逃逸
public void method() {
  A a =  new A();
    ....
  a = null;
}
```

- 结论：能使用局部变量的，不要在方法外定义（堆上分配不需要GC）

```tex
Java8 逃逸分析默认是打开的，也可通过开关控制

-XX:+DoEscapeAnalysis开启逃逸分析
-XX:-DoEscapeAnalysis 关闭逃逸分析
```
## 标量替换

- Hotspot 并未开启栈上分配，但是开启了标量替换

如下：Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了
替换前代码
```java

public static void main(String args[]) {
    alloc();
}
class Point {
    private int x;
    private int y;
}
private static void alloc() {
    Point point = new Point(1,2);
    System.out.println("point.x" + point.x + ";point.y" + point.y);
}

```
替换后的代码

```java

private static void alloc() {
    int x = 1;
    int y = 2;
    System.out.println("point.x = " + x + "; point.y=" + y);
}

```

# 垃圾回收

## 垃圾回收的相关算法

- 标记阶段
  - 引用计数算法
  - 可达性分析算法
- 清除阶段
  - 标记- 清除算法
  - 复制算法
  - 标记-压缩算法

## 引用计数算法

- 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象的引用计数器的值为0，即表示对象A不能在被使用，可进行回收。
- **java未使用该算法**（因为无法处理循环引用）
```java
MyObject myObject1 = new MyObject();
MyObject myObject2 = new MyObject();
myObject1.ref = myObject2;
myObject2.ref = myObject1;
myObject1 = null;
myObject2 = null;
```
当代码执行完line7时，两个对象的引用计数均为2。此时将myObject1和myObject2分别置为null，以前一个对象为例，它的引用计数将减1。
若要满足垃圾回收的条件，需要清除myObject2中的ref这个引用，而要清除掉这个引用的前提条件是myObject2引用的对象被回收，
可是该对象的引用计数也为1，因为myObject1.ref指向了它。

- python使用了引用计数（1.手动解除，2.弱引用）

## 可达性分析

- java c#的垃圾回收选择
- 通过一系列称为GC Roots的对象作为起点，然后向下搜索，搜索所走过的路径称为引用链/Reference Chain，当一个对象到GC Roots没有任何引用链相连时，即该对象不可达，也就说明此对象是不可用的

![](./image/5-gc/202518212252.png)

> GC Roots

- GC Roots可以理解为由堆外指向堆内的引用， 一般而言，GC Roots包括（但不限于）以下几种：

1. Java 方法栈桢中的局部变量；
2. 已加载类的静态变量；
3. JNI handles；
4. 已启动且未停止的 Java 线程。

- 比如说：

```tex
虚拟机栈中引用的对象（参数，局部变量等）
方法区中类静态变量
方法区中常量引用的对象
本地方法栈中引用的对象
被同步锁（synchronized）持有的对象
```




# finalization机制

- GC之前自动的调用 java.lang.Object#finalize方法
- finalize调用是逃离死亡的最后机会
- finalize只会被调用一次

# 清除算法

## 标记-清除

> 描述

当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world， 简称**STW**)，然后进行两项工作，第一项则是标记，第二项则是清除。

- 标记：从引用根节点遍历，标记所有被引用对象（**既不可回收对象**），将标记结果记录在对象的header中
- 清除：将所有对象线性遍历，如果发现没有被标记，则回收

> 缺点

- 效率不算高
- GC时需要停止整个应用
- 清理内存时不连续的，容易产生内存碎片（这样需要维护一个虚拟列表）

## 复制算法

- 适用于存活对象少，垃圾多的场景（新生代）

- 核心思想

```tex

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
```

- 优点

```tex
没有标记和清除过程，实现简单，运行高效
复制过去以后保证空间的连续性，不会出现“碎片”问题
```

- 缺点

```tex
此算法的缺点也是很明显的，就是需要两倍的内存空间。
对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系(意味着对象引用需要更改引用地址)，不管是内存占用或者时间开销也不小。
```

## 标记-压缩

- 执行过程

1. 第一阶段和标记-清除算法一样,从根节点开始标记所有被引用对象
2. 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。
3. 清理边界外所有的空间。

- 优点

```tex
消除了复制算法当中，内存减半的高额代价。
没有碎片化的内存
```

- 缺点

```tex
效率低
移动对象的同时，需要更改对象引用地址
移动过程，需要STW
```




# 复合算法

## 分代收集算法

- 将区域划分成新生代、老年代
- 新生代
  - 区域相对老年代较小，对象生命周期短、存活率低，回收频繁
  - 适用复制算法
- 老年代
  - 区域较大，对象生命周期长、存活率高，回收不及年轻代频繁
  - 一般使用标记清除/标记-压缩算法

## 增量收集算法

- 基本思想

```tex
每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
```

- 缺点

```tex
由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。
```

## 分区算法

*基本思想*:

```tex
分区算法将整个堆空间划分成连续的不同小区间region。
每个小区间都独立使用，独立回收
```

![](./image/5-gc/20210519215957.png)


# 垃圾回收器

## GC分类

- 按线程数分
  - 串型垃圾回收
  - 并行垃圾回收

![](./image/5-gc/20210521232221.png)

- 按工作模式分
  - 独占式
  - 并发式：工作线程和GC线程能同时进行

- 碎片处理方式
  - 压缩式
  - 非压缩式

## 评估GC的性能指标

- 吞吐量
  - 运行用户代码的时间占总运行时间的比例
  - 总运行时间:程序的运行时间＋内存回收的时间
- 暂停时间
  - 执行垃圾收集时，程序的工作线程被暂停的时间。
- 内存占用 
  - Java 堆区所占的内存大小

![](./image/5-gc/20210522145142.png)

## 七种经典回收器

1. 新生代收集器：Serial（复制算法）、ParNew、Parallel Scavenge；

2. 老年代收集器：Serial Old（标记-整理）、Parallel Old、CMS（标记-清除）；

3. 整堆收集器：G1（标记-整理）；

- 搭配关系图
  - 红色虚线：jdk8移除
  - 绿色虚线：jdk14移除
  - 青色虚线：jdk14移除（删除CMS垃圾回收）

![](./image/5-gc/20210522154532.png)

### Serial回收器

- 高延迟
- Serial收集器采用复制算法、串行回收和"Stop-the-World"机制的方式执行内存回收。
- 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的serial old收集器。serial old收集器同样也采用了串行回收(标记-压缩算法)
  - Serial old是运行在client模式下默认的老年代的垃圾回收器
  - Serial old在Server模式下主要有两个用途:①与新生代的Parallelscavenge配合使用作为老年代CMS收集器的后备垃圾收集方案

![](./image/5-gc/20210522174245.png)


### ParNew 回收器

- 采用并行回收的方式执行内存回收
- 年轻代采用复制算法
- JDK14凉了

![](./image/5-gc/20210523095845.png)


### Parallel Scavenge回收器

- **吞吐量优先**
- JDK8默认垃圾回收
- 适合在后台运算而不需要太多交互的任务的业务场景（例如：那些执行批量处理、订单处理、工资支付、科学计算的应用程序。）
- Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel old收集器，用来代替老年代的Serial old收集器。
- Parallel old收集器采用了**标记-压缩算法**，但同样也是基于**并行回收**

![](./image/5-gc/20210523103645.png)




### CMS 回收器

- **低延迟**

- 第一款真正意义上的并发收集器（用户线程和GC线程并发执行）
- 采用标记-清除算法

![](./image/5-gc/20210523110220.png)

- GC阶段
  - 初始标记：标记出GC Roots能直接关联到的对象
  - 并发标记(Concurrent-Mark)阶段:从GC Roots的直接关联对象开始遍历整个对象图的过程
  - 重新标记
  - 并发清除

```tex
有人会觉得既然Mark Sweep会造成内存碎片,那么为什么不把算法换成Mark Compact呢?

因为在清除阶段，用户线程还在使用
```




### G1垃圾回收器

```tex
官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，
所以才担当起“全功能收集器”的重任与期望。
```

- G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region),使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等
- 后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region(比如有些region，回收过后依旧还占很大内存，那么这个回收价值不大)
- JDK9默认垃圾回收

> 特点

- 并行与并发
  - 并行性:G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
  - 并发性:G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
- 分代收集
  - 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
  - 将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代
  - 堆内存一旦占满，就进行fullGC

- 空间整合
  - Region之间是复制算法
- 可预见的时间模型

> 缺点

- 额外内存占用比较大（小内存应用上CMS表现要好点，6-8Gb）

> 参数设置

-XX:+UseG1GC：手动指定G1垃圾回收

-XX:G1HeapRegionsize设置每个Region的大小值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。

-XX:MaxGCPauseMillis:设置期望达到的最大GC停顿时间指标(JVM会尽力,实现，但不保证达到)。默认值是200ms

> G1常见调优

第一步:开启G1垃圾收集器

第二步:设置堆的最大内存

第三步:设置最大的停顿时间

> 适用场景

- 面向服务端应用，针对具有大内存、多处理器的机器。(在普通大小的堆里表现并惊喜)

- 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案;

> Region

![](./image/5-gc/2021523182527.png)

- Humoungous:大对象存储区域
- 设置H的原因

```tex
对于堆中的大对象,默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区,它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。
```

> 垃圾回收过程

- 年轻代GC

```tex
应用程序分配内存，
当年轻代的Eden区用尽时开始年轻代回收过程;
G1的年轻代收集阶段是一个并行的独占式收集器。
在年轻代回收期，G1 GC暂停所有应用程序线程，
启动多线程执行年轻代回收。
然后从年轻代区间移动存活对象到survivor区间或者老年区间，
也有可能是两个区间都会涉及。
```

- 老年代并发标记过程

```tex
当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。
```

- 混合回收

```tex
标记完成马上开始混合回收过程。
对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，
这些空闲区间也就成为了老年代的一部分。
和年轻代不同，老年代的G1回收器和其他GC不同，
G1的老年代回收器不需要整个老年代被回收，
一次只需要扫描/回收一小部分老年代的Region就可以了。
同时，这个老年代Region是和年轻代一起被回收的。
```

- (如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对Gc的评估失败提供了一种失败保护机制，即强力回收。)

![](./image/5-gc/20210523215903.png)

> 年轻代回收过程

- Remembered Set

---

问题：

- 一个对象可能被不同区域的对象引用引用
- 回收新生代不得不扫描老年代（可能老年代的引用指向新生代）

---

解决办法：

- 无论G1还是其他分代收集器，JVM都是使用Remembered set来避免全局扫描
- 每个Region都有一个对应的Remembered set;

- 当我们需要回收某个region时，只需要搜索set，去扫描对应的有指向本region的其他region

![](./image/5-gc/20210523230508.png)

---

> 并发标记

1. 初始化标记阶段
2. 根区域扫描
3. 并发标记：（如果发现区域内都是垃圾，则直接全部回收）
4. 再次标记
5. 独占清理
   1. 计算各个区域的存活对象和GC回收比例，并进行排序识别可以混合回收的区域。为下阶段做铺垫。是STW的。
6. 并发清理

> 混合GC

1. 当越来越多的对象晋升到老年代oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器,即Mixed GC
2. 一部分老年代，而不是全部老年代回收（除了回收整个young region，还会回收一部分的old region）

> FULL GC

- 导致Full GC的原因

1.  Evacuation的时候没有足够的to-space来存放晋升的对象;
2. 并发处理过程完成之前空间耗尽。（堆空间太小）

##  垃圾回收器总结

![](./image/5-gc/20210523234558.png)


## 查看垃圾回收器

- 添加参数：-XX:+PrintCommandLineFlags
  - 可以看到UseParallelGC垃圾回去

```tex
-XX:InitialHeapSize=6291456 -XX:MaxHeapSize=6291456 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
```

- jinfo -flag UseParallelGC 进程号

