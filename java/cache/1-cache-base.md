# 常用缓存淘汰算法

## FIFO:先进先出

> **如果一个数据最先进入缓存，则应该最早淘汰掉**



## LRU:最不常用数据

1. 判断数据最近使用的时间，时间最远的数据优先被淘汰掉

2. 查询和删除应该都说O(1)；*采用 hash + 双向链表的结构*
   1. 查询的时候，通过hash查询到指定的key对应的值
   2. 删除的时候，删除队列里头部数据，同时删除hash里的值

> 为什么使用双向链表？

1. 在添加数据时候，如果遇到重复数据，需要将链表中的数据删除，然后将当前数据入队（放入队列）

   1. 删除数据：这里应用时间复杂度O（1）

      ```java
      node.prev.next = node.next;
      node.next.prev = node.prev;
      ```

> 为什么使用hash

在查询数据的时候，时间复杂度能够达到O（1）

## LFU:最近最少使用

> **一段时间内，数据被使用的次数最少，优先被淘汰**



# 缓存技术选型

1、凌晨突然涌入的巨大流量。【队列削峰】【限流】
2、高并发场景秒杀、抢红包、抢优惠券，快速存取。【缓存】
3、高并发场景超卖、超额抢红包。
4、高并发场景重复抢单。【缓存解决】  



# 缓存应用

> Memcached 

优点：高性能读写，单一的数据类型（key【String】-value【Object】），支持客户端式分布式集群，多线程读写性能
高。
缺点：无持久化，服务端无法实现集群，跨机房数据同步困难，架构扩容复杂度高，不适合处理大规模数据量  

> Redis 

优点：高性能读写，多数据类型支持，数据持久化，高可用架构，支持分布式分片集群，单线程读写性能极高（6.x版本支持
多线程）。
缺点：多线程读写较Mencached慢，不适合处理大规模数据量。  

> Tair

优点：高性能读写，支持三种存储引擎（ddb/rdb/ldb），支持高可用，支持分布式分片集群，支撑了几乎所有淘宝业务的
缓存。
缺点：单机情况下，读写性能较上两种较慢，适合处理大规模数据缓存。  

# JSR107缓存规范

> Java Caching定义了5个核心接口，分别是CachingProvider,CacheManager, Cache, Entry 和 Expiry

*CachingProvider*：定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider
*CacheManager*：定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider拥有。
*Cache*：类似Map的数据结构并临时存储以key为索引的值。一个Cache仅被一个CacheManager所拥有
*Entry*：是一个存储在Cache中的key-value对
*Expiry*：每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置

![image-20220508213638110](image/1-cache-base/image-20220508213638110.png)



# 缓存常见问题

## 缓存穿透

> 概念

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

**恶意请求数据库不存在的数据**

> 如何避免

1. 对查询结果为空的情况也进行缓存，缓存时间设置短一点，如（key-null）
2. 使用布隆过滤器: `在gateway中判断，当前地址请求的商品存不存在，不存在，就不去请求后端的微服务了`

## 缓存雪崩

> 概念

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

**大量的缓存突然失效**

> 如何避免

1. 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀
2. 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

## 缓存击穿

> 概念

如果你的应用中有一些**访问量很高的热点数据**，我们一般会将其放在缓存中以提高访问速度。

另外，为了保持时效性，我们通常还会设置一个过期时间。但是对于这些访问量很高的KEY，我们需要考虑一个问题：当热点KEY在失效的瞬间，海量的请求会不会产生大量的数据库请求，从而导致数据库崩溃？

**某一个热点key失效，直接查询了数据库**

> 解决方案

1. 互斥锁,互斥锁指的是在缓存KEY过期去更新的时候，先让程序去获取锁，只有获取到锁的线程才有资格去更新缓存KEY。（也可以分布式的锁，抢到锁的去更新缓存，没有抢到的先阻塞一下，等待缓存更新完毕）。这个查询DB的并发只有一个，其他的都查询缓存了
2. 永远不过期。（不太好）
3. 使用定时器定时刷新缓存，防止缓存过期
4. **队列术**操作：将请求放入队列中，第一个请求去缓存中查，如果没有，则第一个请求去后端查，其余请求查询缓存

# 布隆过滤器

`布隆过滤器可以判断这个值存不存在`

1. 布隆过滤器由一个二进制的数组组成
2. 当一个字符串，通过hash计算当前字符串的坐标，则将当前坐标至1

![20210713210428](image/1-cache-base/20210713210428.jpg)

如：key，通过三个hash算法，计算了三个位置，下次key再来时，发现这三个1就会判断当前这个值存在

3. 布隆会有误差问题：因为不同的值，hash的坐标可能是相同的

> 解决缓存穿透问题

当数据库查询这个值不存在时候，直接将当前key放入布隆过滤器中

如果下次这个key还来查询，直接不查数据库，通过布隆过滤器进行返回（redisson里有直接封装好的）



## 使用场景

1. 网页爬虫对URL的去重，避免爬取相同的URL地址（在爬取网页时，先再过滤器中判断是否存在，如果存在就不去爬取网站了）
2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱  
3. 缓存穿透

## 缺陷

1. 代码复杂度增大
2. 需要另外维护一个集合来存放缓存的Key
3. 布隆过滤器不支持**删值**操作  
